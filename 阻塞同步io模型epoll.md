索引
	1. 阻塞与非阻塞
	2. 流 和 用户&内核空间、 缓冲区
	3. 流处理：阻塞-缓冲-内核 。
	4. 四大事件
	5. Epoll
	6. 源代码-原理
	

详情：
	1. 阻塞与非阻塞
		a. 阻塞：调用结果返回之前，当前线程被挂起（线程进入非可执行状态，cpu不分配时间片，线程暂停运行），直到有结果后才返回；
			i. 比如你去拿快递，此时快递没到，你没有其他事可做 或者 你必须拿到快递才继续接下来的事情，怎么办？ 你必须等。傻等也不好，所以你可以去睡觉了，快递来了会打电话给你（必须保证能叫醒）
		b. 非阻塞忙轮询：调用不能拿到结果的情况下，当前线程不被挂起，而是立刻返回。
			i. 忙轮询：每隔一段时间就去问快递(或者问缓冲区)货到了没有？ 如此往复，一直到有货。
	2. 流 和 用户&内核空间、 缓冲区
		a. 一个流，可以是 文件，socket, pipe等等 可以进行I/O操作的 内核对象。
		b. 用户空间 & 内核空间
			i. 操作系统采用虚拟存储器，对32位操作系统，其寻址空间（虚拟存储空间）为2的32次方，为4G
			ii. 操作系统的核心是内核，独立于普通的应用程序(代码)，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
			iii. 为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟空间划分为两部分：内核空间 和 用户空间
			iv. Linux, 将最高的1G字节（从虚拟地址的高位0xC00000000 ~ 0xFFFFFFFF）作为内核空间，将较低的3G字节（0x00000000 ~ 0xBFFFFFFF）作为用户空间。
		c. 缓冲区
			i. 为了减少频繁I/O操作而引起频繁的系统调用（慢），大概操作一个流时，更多的以缓冲区为单位进行操作。 用户空间和内核空间都需要缓冲区.
	3. 流处理：阻塞-缓冲-内核 。
		a. 在阻塞I/O模式下，一个线程只能处理一个流的I/O事件。要想处理多个流，要么多进程（fork）,要么多线程（pthread_create）,但这两种方法都不高效。
		b. 非阻塞忙轮询模式：每次 把所有的流都轮询一遍，周而复始。缺点明显：空转，白白浪费cpu.
		 ab这两种，在a阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒；而b非阻塞模式下 则把I/O事件交给其 对象 处理甚至直接忽略。
		c. Select/poll ：代理。解决cpu空转问题。
			i. 引入一个select代理，同时观察许多流的i/o事件：当空闲的时候，当前select线程阻塞，下面的轮询代码不执行；当有一个或者多个流有I/O事件的时候，该select线程从阻塞中醒来，继续下面的 轮询。（可以不叫 忙轮询 了）。
		d. 总结： 我们用select仅仅知道了 什么时候有I/O事件发生了，但并不知道哪一个或者几个，我们只能继续无差别的轮询，找出能读/写的流，对他们进行操作。复杂度 O(N)
	
	4. 唤醒 挂起/阻塞进程的事件：
		假设有一个管道，进程A为管道写入方，进程B为管道读取方
		a. 缓冲区为空，B被阻塞
		b. 某个点，A往管道里写入数据，缓冲区由空转为非空，产生【缓冲区非空】事件，唤醒B
		c. B并未读取数据，缓冲区逐渐写满，缓冲区写满，产生【缓冲区满】事件，阻塞A
		d. B读数据，缓冲区有空间了，产生【缓冲区非满】事件，唤醒A
		e. A并未写入，B读空了，产生【缓冲区空】事件，阻塞B。
		总结：这四个I/O事件是进行阻塞同步的根本。
	5. Epoll
		Epoll 可以理解为 event poll ,区别于忙轮询和无差别轮询，eoll会把哪个流发生了什么I/O事件通知我们，负责读o(K),k为流个数。
		a. Epoll_create创建一个epoll对象；epollfd = epoll_create();
		b. Epoll_ctl(epoll_add&epoll_del),网epoll对象正增加/删除一个流的某一个事件。
			i. Epoll_ctl(epollfd,EPOLL_CTL_ADD,socket,EPOLLIN); 缓冲区非空时epoll_wait返回
			ii. Epoll_ctl(epollfd,EPOLL_CTL_DEL,socket,EPOLLOUT);缓冲区非满时epoll_wait返回。
		c. Epoll_wait(epollfd)等待注册的事件发生
		注：当对一个非阻塞流的读写发生 缓冲区 满或 缓冲区 空 的时候，write/read会返回-1，并设置errno = EAGAIN.
		        而epoll只关心 缓冲区非满（开始产生EPOLLOUT事件） 和 缓冲区非空 （开始有EPOLLIN事件）。
	6. 代码：
		a. 阻塞
		b. 非阻塞忙轮询
			i. While(true){
				For I in stream[]{
					If I  has  data 
						Read untill unavaliable
				}
			}
		c. io复用无差别轮询
			i. While(true) {
				Select(stram[]);// 阻塞
				For I in stream[]{
					If I  has data 
						Read untill unavaliable
				}
			}
		d. Epoll  事件通知
			i. While (true) {
				Active_stream[] = epoll_wait(epollfd)//阻塞 但会知道哪个流哪个事件，不用轮询
				For I  in active_stream[] {
					Read or write till unavaliable
				}
			} 
	阻塞，非阻塞忙轮询，io复用无差别轮询都是同步，因为都会等到 内核把数据准备好了并触发事件了。然后进程过来rc写入到用户控件。.
		

